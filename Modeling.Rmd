---
title: "Modeling"
author: "aaron till"
date: "5/29/2018"
output: html_document
---
```{r}
#library(randomForest)
library(caret)
library(glmnet)

```
 
 
# Lasso regression Summerkill just pop.

```{r source - }

x_summer <- model.matrix(Summerkill ~ Mean_Surf_Temp + Mean_Surf_Zscore + layer_dif + Schmidt + Cumulative_Above_0 + population, main_data_census) 


y_summer <- ifelse(main_data_census$Summerkill == 1, 1, 0)

```

```{r}

lambdatest <- glmnet(x_summer, y_summer, family = "binomial", alpha = 1)
plot(lambdatest, xvar = 'lambda')

```

```{r observing lambdas}
set.seed(1234)


lasso_regression_lambda_summer <- cv.glmnet(x_summer, y_summer, family = "binomial", alpha = 1) # alpha = 0 ridge, 1 for lasso, between 0 and 1 for elastic 

plot(lasso_regression_lambda_summer)

```

```{r making final lasso regression model}

lasso_regression_model_summer <- glmnet(x_summer, y_summer, family = "binomial", alpha = 1, lambda = lasso_regression_lambda_summer$lambda.min) 
# alpha = 0 ridge, 1 for lasso, between 0 and 1 for elastic 
#use $lambda.1se instead of $lambda.min for simpler but less accurate model

coef(lasso_regression_model_summer)

```
# Ridge regression Summerkill pop + coords

```{r}

x_summer_coords <- model.matrix(Summerkill ~ Mean_Surf_Temp + Mean_Surf_Zscore + layer_dif + Schmidt + Cumulative_Above_0 + population + V1 + V2, main_data_census) 


y_summer_coords <- ifelse(main_data_census$Summerkill == 1, 1, 0)

```

```{r}

lambdatest <- glmnet(x_summer_coords, y_summer_coords, family = "binomial", alpha = 0)
plot(lambdatest, xvar = 'lambda')

```

```{r observing lambdas}
set.seed(1234)


ridge_regression_lambda_summer <- cv.glmnet(x_summer_coords, y_summer_coords, family = "binomial", alpha = 0) # alpha = 0 ridge, 1 for lasso, between 0 and 1 for elastic 

plot(ridge_regression_lambda_summer)

```

```{r making final lasso regression model}

ridge_regression_model_summer <- glmnet(x_summer_coords, y_summer_coords, family = "binomial", alpha = 0, lambda = ridge_regression_lambda_summer$lambda.min) 
# alpha = 0 ridge, 1 for lasso, between 0 and 1 for elastic 
#use $lambda.1se instead of $lambda.min for simpler but less accurate model

coef(ridge_regression_model_summer)

```

# Lasso regression coords + pop

x_summer_coords 
y_summer_coords
from ridge regression above



```{r}

x_all <- model.matrix(Summerkill ~ . , select(main_data_census, -FType, - FCode, - GNIS_Nm, - ReachCd, - Prmnn_I, - Year, - GNIS_ID, - site_id, - WBIC, - Winterkill, - Infection, - Anthropogenic, - MME, - Month, - Season, - Spring))

y_all <- ifelse(main_data_census$Summerkill == 1, 1, 0)


```

```{r}

lambdatest <- glmnet(x_all, y_all, family = "binomial", alpha = 1)
plot(lambdatest, xvar = 'lambda')
 
```

```{r observing lambdas}
set.seed(1234)

grid=10^seq(10,-15,length=100) # set lambda equal to for checking if more extensive lambda needed, no difference

lasso_regression_coords_lambda_summer <- cv.glmnet(x_all, y_all, family = "binomial", alpha = 1) # alpha = 0 ridge, 1 for lasso, between 0 and 1 for elastic 

plot(lasso_regression_coords_lambda_summer)

```

```{r making final lasso regression model}

lasso_regression_coords_model_summer <- glmnet(x_summer_coords, y_summer_coords, family = "binomial", alpha = 1, lambda = lasso_regression_coords_lambda_summer$lambda.min) 
# alpha = 0 ridge, 1 for lasso, between 0 and 1 for elastic 
#use $lambda.1se instead of $lambda.min for simpler but less accurate model

coef(lasso_regression_coords_model_summer)

```


 
# Normal Logistic Regression modeling + dataset building


```{r creating reg_predictions and quartiles}
set.seed(1234)

regression_model <- glm(Summerkill ~ Mean_Surf_Temp + Mean_Surf_Temp + Mean_Surf_Zscore + layer_dif  + Schmidt + Cumulative_Above_0 + population + V1 + V2, family = 'binomial', data=main_data_census) 

reg_predictions <- na.omit(future_data_census) 
reg_predictions$Prob <- predict(regression_model, na.omit(future_data_census), type = 'response')
reg_predictions$quantile <- quantile(reg_predictions$Prob,probs = c(min(reg_predictions$Prob), max(reg_predictions$Prob)), na.rm = TRUE)

coef(regression_model)

```

```{r forecasting}
set.seed(1234)

a <- reg_predictions$Prob
simulation_log_regress <- rbinom(length(a), 1, prob = a)

reg_predictions$Summerkill_forecast <- simulation_log_regress

```


# Building datasets for shrinkage model outputs


#Building lasso pop predictions dataset 

```{r}

lasso_summer_predictions <- future_data_census

lasso_summer_predictions$Summerkill <- 0 # Not sure why I am forced to make this

newx<- model.matrix(Summerkill ~ Mean_Surf_Temp + Mean_Surf_Zscore + layer_dif  + Schmidt + Cumulative_Above_0 + population, lasso_summer_predictions) #why NEWX has to be a fake model and not just a dataset is unclear)



lasso_summer_predictions$Prob <- as.vector(predict(lasso_regression_model_summer, newx= newx, type = 'response'))


lasso_summer_predictions$quantile <- quantile(lasso_summer_predictions$Prob,probs = c(.01, 25, 75)/100, na.rm = TRUE)

```

```{r forecasting}
set.seed(1234)

a <- lasso_summer_predictions$Prob
simulation_log_regress <- rbinom(length(a), 1, prob = a)

lasso_summer_predictions$Summerkill_forecast <- simulation_log_regress

```


#Building ridge pop+coords predictions dataset 


```{r}
ridge_summer_predictions <- future_data_census


ridge_summer_predictions$Summerkill <- 0 # Not sure why I am forced to make this


newx<- model.matrix(Summerkill ~ Mean_Surf_Temp + Mean_Surf_Zscore + layer_dif  + Schmidt + Cumulative_Above_0 + population + V1 + V2, ridge_summer_predictions) #why NEWX has to be a fake model and not just a dataset is unclear)


ridge_summer_predictions$Prob <- as.vector(predict(ridge_regression_model_summer, newx= newx, type = 'response'))


ridge_summer_predictions$quantile <- quantile(ridge_summer_predictions$Prob,probs = c(.01, 25, 75)/100, na.rm = TRUE)


```


```{r forecasting}
set.seed(1234)

a <- ridge_summer_predictions$Prob
simulation_log_regress <- rbinom(length(a), 1, prob = a)

ridge_summer_predictions$Summerkill_forecast <- simulation_log_regress


```


#Building lasso coords/pop predictions dataset 

```{r}

lasso_coords_summer_predictions <- future_data_census

lasso_coords_summer_predictions$Summerkill <- 0 # Not sure why I am forced to make this

newx<- model.matrix(Summerkill ~ Mean_Surf_Temp + Mean_Surf_Zscore + layer_dif  + Schmidt + Cumulative_Above_0 + population + V1 + V2, lasso_coords_summer_predictions) #why NEWX has to be a fake model and not just a dataset is unclear)



lasso_coords_summer_predictions$Prob <- as.vector(predict(lasso_regression_coords_model_summer, newx= newx, type = 'response'))


lasso_coords_summer_predictions$quantile <- quantile(lasso_coords_summer_predictions$Prob,probs = c(.01, 25, 75)/100, na.rm = TRUE)

```

```{r forecasting}
set.seed(1234)

a <- lasso_coords_summer_predictions$Prob
simulation_log_regress <- rbinom(length(a), 1, prob = a)

lasso_coords_summer_predictions$Summerkill_forecast <- simulation_log_regress

```


# Testing Models

```{r creating 50% random split for training/testing}

set.seed(1234)

train_indices <- sample(1:nrow(main_data_census), size = 528339 , replace = FALSE) # 4/5ths = 528339 #half = 330212
train_data <- slice(main_data_census, train_indices) 
test_data  <- slice(main_data_census, -train_indices)


flds <- createFolds(main_data_census, k = 5, list = TRUE, returnTrain = TRUE)

```


```{r}
#cross validation specifications
cv_5 = trainControl(method = 'cv', number = 5)

#shrinkage model specificiations
tuneGrid=expand.grid(.alpha=1,.lambda=seq(lasso_regression_lambda_summer$lambda.min))

#lasso model with cross validation (times out here)
lasso_regression_k <- train(factor(Summerkill) ~ Mean_Surf_Temp + Mean_Surf_Zscore + layer_dif + Schmidt + Cumulative_Above_0 + population, data = main_data_census, trControl = cv_5, family = 'binomial' )

# new dataset
lasso_model_test_k <- main_census

# dummy model for creating predictions...not sure if this is correctly specified
newx <- model.matrix(Summerkill ~ Mean_Surf_Temp + Mean_Surf_Zscore + layer_dif + Schmidt + Cumulative_Above_0 + population, main_data_census)

# making probabilities
lasso_model_test_k$Prob <- as.vector(predict(lasso_regression_k), newx = newx, type = 'response')
  
#comparing probabilities
ggplot(lasso_model_test_k, aes(x = factor(Summerkill), y = log(Prob))) +
  geom_boxplot()

lasso_model_test_k %>% group_by(Summerkill) %>% summarise(mean(Prob))
```

# Lasso Regression pop summerkill testing - test/training

```{r source - http://www.sthda.com/english/articles/36-classification-methods-essentials/149-penalized-logistic-regression-essentials-in-r-ridge-lasso-and-elastic-net/}

x_train <- model.matrix(Summerkill ~ Mean_Surf_Temp + Mean_Surf_Zscore + layer_dif  + Schmidt + Cumulative_Above_0 + population, train_data) 


y_train <- ifelse(train_data$Summerkill == 1, 1, 0)

```


making training model

```{r}
lasso_regression_train <- glmnet(x_train, y_train, family = "binomial", alpha = 1, lambda = lasso_regression_lambda_summer$lambda.min) # alpha = 0 ridge, 1 for lasso, between 0 and 1 for elastic 
#use lambda.1se instead of lambda.min for simpler but less accurate model
#can use lambda from regular model

#coef(lasso_regression_model)

``` 

testing for missclassification

```{r}

lasso_regression_test <- model.matrix(Summerkill ~ Mean_Surf_Temp + Mean_Surf_Zscore + layer_dif + Schmidt + Cumulative_Above_0 + population, test_data)



probabilities <- lasso_regression_train %>% predict(newx = lasso_regression_test)
predicted_classes <- ifelse(probabilities > 0.5, 1, 0)
# Model accuracy 
observed_classes <- test_data$Summerkill
mean(predicted_classes == observed_classes)


```

testing for average probability seperation

```{r}

lasso_model_test <- test_data


lasso_model_test$Prob <- as.vector(predict(lasso_regression_train, newx= lasso_regression_test, type = 'response'))


ggplot(lasso_model_test, aes(x = factor(Summerkill), y = log(Prob))) +
  geom_boxplot()

lasso_model_test %>% group_by(Summerkill) %>% summarise(mean(Prob))

```




# Ridge Regression pop + coords summerkill testing - test/training


```{r}

x_train_coords <- model.matrix(Summerkill ~ Mean_Surf_Temp + Mean_Surf_Zscore + layer_dif  + Schmidt + Cumulative_Above_0 + population + V1 + V2, train_data) 


y_train_coords <- ifelse(train_data$Summerkill == 1, 1, 0)

```

making training model

```{r}
ridge_regression_train <- glmnet(x_train_coords, y_train_coords, family = "binomial", alpha = 0, lambda = ridge_regression_lambda_summer$lambda.min) # alpha = 0 ridge, 1 for lasso, between 0 and 1 for elastic 
#use lambda.1se instead of lambda.min for simpler but less accurate model
#can use lambda from regular model

#coef(lasso_regression_model)

``` 

testing for missclassification

```{r}

ridge_regression_test <- model.matrix(Summerkill ~ Mean_Surf_Temp + Mean_Surf_Zscore + layer_dif + Schmidt + Cumulative_Above_0 + population + V1 + V2, test_data)



probabilities <- ridge_regression_train %>% predict(newx = ridge_regression_test)
predicted_classes <- ifelse(probabilities > 0.5, 1, 0)
# Model accuracy 
observed_classes <- test_data$Summerkill
mean(predicted_classes == observed_classes)


```

testing for average probability seperation

```{r}

ridge_model_test <- test_data


ridge_model_test$Prob <- as.vector(predict(ridge_regression_train, newx= ridge_regression_test, type = 'response'))


ggplot(ridge_model_test, aes(x = factor(Summerkill), y = log(Prob))) +
  geom_boxplot()

ridge_model_test %>% group_by(Summerkill) %>% summarise(mean(Prob))

```


# Lasso COORDS + pop summerkill testing - test/training


x_train_coords / y_train_coords same as lasso



making training model

```{r}
lasso_coords_regression_train <- glmnet(x_train_coords, y_train_coords, family = "binomial", alpha = 1, lambda = lasso_regression_coords_lambda_summer$lambda.min) # alpha = 0 ridge, 1 for lasso, between 0 and 1 for elastic 
#use lambda.1se instead of lambda.min for simpler but less accurate model
#can use lambda from regular model

#coef(lasso_regression_model)

``` 

testing for missclassification

```{r}

lasso_coords_regression_test <- model.matrix(Summerkill ~ Mean_Surf_Temp + Mean_Surf_Zscore + layer_dif + Schmidt + Cumulative_Above_0 + population + V1 + V2, test_data)



probabilities <- lasso_coords_regression_train %>% predict(newx = lasso_coords_regression_test)
predicted_classes <- ifelse(probabilities > 0.5, 1, 0)
# Model accuracy 
observed_classes <- test_data$Summerkill
mean(predicted_classes == observed_classes)


```

testing for average probability seperation

```{r}

lasso_coords_model_test <- test_data


lasso_coords_model_test$Prob <- as.vector(predict(lasso_coords_regression_train, newx= lasso_coords_regression_test, type = 'response'))


ggplot(lasso_coords_model_test, aes(x = factor(Summerkill), y = log(Prob))) +
  geom_boxplot()

lasso_coords_model_test %>% group_by(Summerkill) %>% summarise(mean(Prob))

```

# regular regression testing


making training model

```{r}
reg_train <- glm(Summerkill ~ Mean_Surf_Temp + Mean_Surf_Temp + Mean_Surf_Zscore + layer_dif  + Schmidt + Cumulative_Above_0 + population + V1 + V2 , family = 'binomial', data=train_data) 
``` 

testing for missclassification

```{r}



probabilities <- predict(reg_train, test_data, type = 'response')
predicted_classes <- ifelse(probabilities > 0.5, 1, 0)
observed_classes <- test_data$Summerkill
mean(predicted_classes == observed_classes)


```

testing for average probability seperation

```{r}

reg_predictions_test <- test_data

reg_predictions_test$Prob <- predict(reg_train, test_data, type = 'response')




ggplot(reg_predictions_test, aes(x = factor(Summerkill), y = log(Prob))) +
  geom_boxplot()

reg_predictions_test %>% group_by(Summerkill) %>% summarise(mean(Prob))

```


#Optional - Trend


```{r looking at trend of predictions}

change_MME_freq_future <- glm(Summerkill_forecast ~ Year, family = 'binomial', data=  )


summary(change_MME_freq_future) 

```

# User Model Data

```{r user data}


Lake_Risk_Assesment <- lasso_summer_predictions %>% select(WBIC, site_id, Year, Prob, Mean_Surf_Temp) %>%
  filter(Year > 2020) %>%
  group_by(WBIC, site_id, Year) %>%
  summarise('Summerkill Probability' = sum(Prob), 'Mean Surface Temperature' = mean(Mean_Surf_Temp))

write.csv(Lake_Risk_Assesment, "Lake_Risk_Assessment.csv")

```


# Lasso Just Winterkill - needs fixing

```{r source - }

x_winter <- model.matrix(Winterkill ~ Year + Mean_Surf_Temp + Mean_Surf_Zscore + layer_dif + Season + Schmidt + Variance_After_Ice_30 + Cumulative_Above_0 + Ice_Duration + V2, main_data) 


y_winter <- ifelse(main_data$Winterkill == 1, 1, 0)

```



```{r observing lambdas and making final lasso regression model}
set.seed(1234)


lasso_regression_lambda_winter <- cv.glmnet(x_winter, y_winter, family = "binomial", alpha = 1) # alpha = 0 ridge, 1 for lasso, between 0 and 1 for elastic 

lasso_regression_model_winter <- glmnet(x_winter, y_winter, family = "binomial", alpha = 1, lambda = lasso_regression_lambda_winter$lambda.1se) # alpha = 0 ridge, 1 for lasso, between 0 and 1 for elastic 
#use lambda.1se instead of lambda.min for simpler but less accurate model

coef(lasso_regression_model_winter)

```
